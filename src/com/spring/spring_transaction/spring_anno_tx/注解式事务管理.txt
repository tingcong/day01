注解方式实现
使用注解实现Spring的声明式事务管理，更加简单！
步骤：
	1） 必须引入Aop相关的jar文件
	2） bean.xml中指定注解方式实现声明式事务管理以及应用的事务管理器类
	3）在需要添加事务控制的地方，写上: @Transactional

@Transactional注解：
	1）应用事务的注解
	2）定义到方法上： 当前方法应用spring的声明式事务
	3）定义到类上：   当前类的所有的方法都应用Spring声明式事务管理;
	4）定义到父类上： 当执行父类的方法时候应用事务。


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
    	 http://www.springframework.org/schema/beans/spring-beans.xsd
     	 http://www.springframework.org/schema/context
         http://www.springframework.org/schema/context/spring-context.xsd
         http://www.springframework.org/schema/aop
         http://www.springframework.org/schema/aop/spring-aop.xsd
         http://www.springframework.org/schema/tx
     	 http://www.springframework.org/schema/tx/spring-tx.xsd">


	<!-- 1. 数据源对象: C3P0连接池 -->
	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="driverClass" value="com.mysql.jdbc.Driver"></property>
		<property name="jdbcUrl" value="jdbc:mysql:///hib_demo"></property>
		<property name="user" value="root"></property>
		<property name="password" value="root"></property>
		<property name="initialPoolSize" value="3"></property>
		<property name="maxPoolSize" value="10"></property>
		<property name="maxStatements" value="100"></property>
		<property name="acquireIncrement" value="2"></property>
	</bean>

	<!-- 2. JdbcTemplate工具类实例 -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource"></property>
	</bean>

	<!-- 事务管理器类 -->
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"></property>
	</bean>

	<!-- 开启注解扫描 -->
	<context:component-scan base-package="cn.itcast.b_anno"></context:component-scan>

	<!-- 注解方式实现事务： 指定注解方式实现事务 -->
	<tx:annotation-driven transaction-manager="txManager"/>
</beans>






事务属性
@Transactional(
			readOnly = false,  // 读写事务
			timeout = -1,       // 事务的超时时间不限制
			noRollbackFor = ArithmeticException.class,  // 遇到数学异常不回滚
			isolation = Isolation.DEFAULT,              // 事务的隔离级别，数据库的默认
			propagation = Propagation.REQUIRED			// 事务的传播行为
	)
	public void save(Dept dept){}




事务传播行为:
	Propagation.REQUIRED
		指定当前的方法必须在事务的环境下执行；
		如果当前运行的方法，已经存在事务， 就会加入当前的事务；
	Propagation.REQUIRED_NEW
		指定当前的方法必须在事务的环境下执行；
		如果当前运行的方法，已经存在事务：  事务会挂起； 会始终开启一个新的事务，执行完后；  刚才挂起的事务才继续运行。


举例：
Class Log{
		Propagation.REQUIRED
		insertLog();
}

	Propagation.REQUIRED
	Void  saveDept(){
		insertLog();    // 加入当前事务
		.. 异常, 会回滚
		saveDept();
	}


	Class Log{
		Propagation.REQUIRED_NEW
		insertLog();
}

	Propagation.REQUIRED
	Void  saveDept(){
		insertLog();    // 始终开启事务
		.. 异常, 日志不会回滚
		saveDept();
	}
